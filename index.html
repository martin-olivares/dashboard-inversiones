<!DOCTYPE html>
<html lang="es" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard Financiero Pro</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --background: #0d1117;
            --surface-1: #161b22;
            --surface-2: #21262d;
            --border-color: #30363d;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --accent: #58a6ff;
        }
        body { 
            font-family: 'Be Vietnam Pro', sans-serif; 
            background-color: var(--background); 
            color: var(--text-primary);
        }
        [v-cloak] { display: none; }
        .chart-container { position: relative; height: 400px; }
        .gradient-border {
            border: 1px solid transparent;
            background: linear-gradient(var(--surface-1), var(--surface-1)) padding-box, linear-gradient(to right, #30363d, #505a66) border-box;
        }
        .loader {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            display: inline-block;
            border-top: 3px solid var(--accent);
            border-right: 3px solid transparent;
            box-sizing: border-box;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="antialiased">

    <div id="app" v-cloak class="max-w-screen-xl mx-auto p-4 sm:p-6 lg:p-8">
        <header class="mb-8">
            <h1 class="text-3xl font-bold tracking-tight text-white">Dashboard Financiero</h1>
            <p class="text-text-secondary">Análisis de activos con IA integrada</p>
        </header>

        <main class="space-y-6">
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                <div class="md:col-span-1 p-5 bg-surface-1 rounded-lg gradient-border">
                    <h2 class="font-semibold mb-3 text-white">Control de Activos</h2>
                    <div class="space-y-3">
                        <input type="text" v-model="newStockTicker" @keyup.enter="addStock" placeholder="Añadir ticker, ej: AAPL" class="w-full px-3 py-2 bg-background border border-border-color rounded-md focus:ring-2 focus:ring-accent focus:border-accent transition placeholder:text-text-secondary">
                        <button @click="addStock" :disabled="isLoading" class="w-full bg-accent text-white font-bold px-4 py-2 rounded-md transition-opacity hover:opacity-90 disabled:bg-gray-500 disabled:cursor-not-allowed">
                            <span v-if="!isLoading">Agregar</span>
                            <span v-if="isLoading">Cargando...</span>
                        </button>
                         <p v-if="error" class="text-red-400 text-xs text-center pt-1">{{ error }}</p>
                    </div>
                </div>
                <div v-if="!isLoadingInitial && trackedStocks.length > 0" class="md:col-span-2 grid grid-cols-2 sm:grid-cols-4 gap-4">
                    <kpi-card v-for="ticker in trackedStocks.slice(0, 4)" :key="ticker" :stock="stockData[ticker]" :is-active="activeDetailStock === ticker" @select="setActiveDetail" @remove="removeStock"></kpi-card>
                </div>
                <div v-if="isLoadingInitial" class="md:col-span-2 flex items-center justify-center bg-surface-1 rounded-lg gradient-border">
                    <div class="loader"></div>
                </div>
            </div>
            
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                <div class="lg:col-span-2 p-5 bg-surface-1 rounded-lg gradient-border">
                     <div class="flex flex-wrap justify-between items-center mb-4 gap-2">
                        <h3 class="font-semibold text-white">Rendimiento Histórico y Proyectado</h3>
                        <div class="flex flex-wrap justify-center gap-2">
                            <button v-for="ticker in trackedStocks" @click="toggleStockInChart(ticker)" :class="[selectedStocksInChart.includes(ticker) ? 'bg-accent text-white font-semibold' : 'bg-surface-2 text-text-secondary hover:bg-border-color', 'px-3 py-1 text-xs font-medium rounded-full transition-all duration-200']">
                                {{ ticker }}
                            </button>
                        </div>
                    </div>
                    <div class="chart-container">
                        <canvas id="priceChart"></canvas>
                    </div>
                </div>
                <div class="p-5 bg-surface-1 rounded-lg gradient-border">
                    <detail-view v-if="activeDetailStock" :stock="stockData[activeDetailStock]" @analyze="analyzeWithGemini"></detail-view>
                    <div v-else class="flex flex-col items-center justify-center h-full text-center">
                        <p class="font-semibold text-white">Análisis Detallado</p>
                        <p class="text-text-secondary text-sm">Selecciona un activo para ver sus detalles y análisis con IA.</p>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        const { createApp, ref, reactive, onMounted, watch } = Vue;

        const kpiCard = {
            props: ['stock', 'isActive'],
            template: `
                <div @click="$emit('select', stock.ticker)" :class="[isActive ? 'bg-accent/10 border-accent' : 'border-transparent', 'relative p-4 bg-surface-1 rounded-lg border-2 cursor-pointer transition-colors duration-300 gradient-border']">
                    <button @click.stop="$emit('remove', stock.ticker)" class="absolute top-2 right-2 text-text-secondary hover:text-red-400 text-lg font-bold">&times;</button>
                    <p class="text-xs text-text-secondary">{{ stock.ticker }}</p>
                    <p class="text-2xl font-bold text-white my-1">$ {{ stock.lastPrice.toFixed(2) }}</p>
                    <p class="text-sm font-semibold" :class="stock.isPositive ? 'text-green-400' : 'text-red-400'">
                        {{ stock.isPositive ? '+' : '' }}{{ stock.six_month_return.toFixed(2) }}%
                    </p>
                </div>`
        };

        const detailView = {
            props: ['stock'],
            emits: ['analyze'],
            data() { return { isAnalyzing: false, analysis: null, error: null } },
            methods: {
                async performAnalysis() {
                    this.isAnalyzing = true; this.error = null; this.analysis = null;
                    const result = await this.$emit('analyze', this.stock.ticker, this.stock.name);
                    if (result) {
                        this.analysis = marked.parse(result.replace(/#/g, ' '));
                    } else { this.error = "No se pudo obtener el análisis."; }
                    this.isAnalyzing = false;
                }
            },
            template: `
                <div class="flex flex-col h-full">
                    <div class="mb-3">
                        <h3 class="font-bold text-lg text-white">{{ stock.name }}</h3>
                        <p class="text-sm text-text-secondary">{{ stock.financials['Market Cap'] }}</p>
                    </div>
                    <button @click="performAnalysis" :disabled="isAnalyzing" class="w-full bg-accent text-white font-bold px-4 py-2 rounded-md transition hover:opacity-90 disabled:bg-gray-500 text-sm mb-3">
                        <span v-if="!isAnalyzing">Análisis con IA</span>
                        <span v-if="isAnalyzing">Generando...</span>
                    </button>
                    <div class="flex-grow space-y-2 overflow-y-auto" style="max-height: 280px;">
                        <div v-if="isAnalyzing" class="text-center p-4"><div class="loader inline-block"></div></div>
                        <div v-if="analysis" class="prose prose-sm prose-invert text-text-secondary" v-html="analysis"></div>
                        <p v-if="!analysis && !isAnalyzing" class="text-text-secondary text-sm">
                            {{ stock.description.substring(0, 250) }}...
                        </p>
                    </div>
                </div>`
        };

        createApp({
            components: { kpiCard, detailView },
            setup() {
                const stockData = reactive({});
                const trackedStocks = ref([]);
                const selectedStocksInChart = ref([]);
                const activeDetailStock = ref(null);
                const newStockTicker = ref('');
                const isLoading = ref(false);
                const isLoadingInitial = ref(true);
                const error = ref(null);
                let chartInstance = null;
                
                const API_ENDPOINT = 'https://cerulean-cupcake-1f5893.netlify.app/.netlify/functions/fetch-stock';

                const loadStocksFromStorage = () => {
                    const stored = localStorage.getItem('trackedStocks');
                    return stored ? JSON.parse(stored) : ['TSLA', 'AMZN', 'MELI', 'GOOGL'];
                };

                const saveStocksToStorage = () => {
                    localStorage.setItem('trackedStocks', JSON.stringify(trackedStocks.value));
                };

                const analyzeWithGemini = async (ticker, stockName) => {
                    try {
                        const response = await fetch(`${API_ENDPOINT}?ticker=${ticker}&action=analyze&stockName=${encodeURIComponent(stockName)}`);
                        if (!response.ok) throw new Error('Network error');
                        const data = await response.json();
                        return data.analysis;
                    } catch (e) {
                        console.error("Error:", e);
                        return null;
                    }
                };
                
                const fetchStockData = async (ticker) => {
                    error.value = null;
                    if (!API_ENDPOINT || API_ENDPOINT.includes('tu-sitio')) {
                        error.value = "Configura API URL.";
                        return null;
                    }
                    try {
                        const response = await fetch(`${API_ENDPOINT}?ticker=${ticker}`);
                        if (!response.ok) throw new Error('Network error');
                        const { priceData, overviewData } = await response.json();
                        if (priceData.Note || overviewData.Note) throw new Error('API limit reached');
                        if (priceData['Error Message'] || !overviewData.Symbol) throw new Error(`Invalid data for ${ticker}`);
                        return adaptApiData(priceData, overviewData, ticker);
                    } catch (e) {
                        console.error(`Error for ${ticker}:`, e);
                        error.value = e.message || `Could not fetch data for ${ticker}`;
                        return null;
                    }
                };

                const adaptApiData = (priceData, overviewData, ticker) => {
                    const timeSeries = priceData['Monthly Adjusted Time Series'];
                    const dates = Object.keys(timeSeries).sort((a, b) => new Date(a) - new Date(b)).slice(-12);
                    const prices = dates.map(date => parseFloat(timeSeries[date]['4. close']));
                    const lastPrice = prices[prices.length - 1];
                    const sixMonthAgoPrice = prices.length > 6 ? prices[prices.length - 7] : prices[0];
                    const six_month_return = ((lastPrice - sixMonthAgoPrice) / sixMonthAgoPrice) * 100;
                    
                    let trend = (lastPrice - prices[prices.length - 4]) / 3;
                    let projection = [];
                    let projectedPrice = lastPrice;
                    for (let i = 0; i < 6; i++) {
                        projectedPrice += trend + ((Math.random() - 0.45) * (lastPrice * 0.05));
                        projection.push(projectedPrice);
                    }
                    
                    return {
                        ticker, name: overviewData.Name, description: overviewData.Description,
                        financials: {
                            'P/E': parseFloat(overviewData.PERatio),
                            'Market Cap': (parseFloat(overviewData.MarketCapitalization) / 1e9).toFixed(2) + 'B USD',
                            'EPS': parseFloat(overviewData.EPS),
                        },
                        prices, lastPrice, six_month_return, isPositive: six_month_return >= 0,
                        projection, projected_price: projection[5] || lastPrice,
                        projected_return: ((projection[5] || lastPrice) - lastPrice) / lastPrice * 100,
                        color: `rgba(${Math.floor(Math.random()*155)+100},${Math.floor(Math.random()*155)+100},${Math.floor(Math.random()*155)+100},1)`
                    };
                };

                const addStock = async () => {
                    const tickerToAdd = newStockTicker.value.toUpperCase().trim();
                    if (!tickerToAdd || trackedStocks.value.includes(tickerToAdd)) return;
                    
                    isLoading.value = true;
                    const newData = await fetchStockData(tickerToAdd);
                    isLoading.value = false;

                    if (newData) {
                        stockData[tickerToAdd] = newData;
                        trackedStocks.value.push(tickerToAdd);
                        selectedStocksInChart.value.push(tickerToAdd);
                        newStockTicker.value = '';
                        saveStocksToStorage();
                    }
                };

                const removeStock = (ticker) => {
                    trackedStocks.value = trackedStocks.value.filter(t => t !== ticker);
                    selectedStocksInChart.value = selectedStocksInChart.value.filter(t => t !== ticker);
                    if (activeDetailStock.value === ticker) activeDetailStock.value = null;
                    delete stockData[ticker];
                    saveStocksToStorage();
                };
                
                const initializeChart = () => {
                    const ctx = document.getElementById('priceChart').getContext('2d');
                    chartInstance = new Chart(ctx, {
                        type: 'line',
                        options: { 
                            responsive: true, maintainAspectRatio: false,
                            plugins: { legend: { display: false } },
                            scales: { 
                                x: { grid: { color: 'rgba(255, 255, 255, 0.1)' }, ticks: { color: 'var(--text-secondary)' } }, 
                                y: { grid: { color: 'rgba(255, 255, 255, 0.1)' }, ticks: { color: 'var(--text-secondary)', callback: (v) => '$' + v } }
                            }
                        }
                    });
                };
                
                const updateChart = () => {
                    if (!chartInstance) return;
                    const labels = Array.from({length: 18}, (_, i) => i < 12 ? `M${i-11}`: `P${i-11}`);
                    chartInstance.data.labels = labels;
                    chartInstance.data.datasets = [];
                    const createGlowGradient = (color) => {
                        const gradient = chartInstance.ctx.createLinearGradient(0, 0, 0, 400);
                        gradient.addColorStop(0, color.replace('1)', '0.6)'));
                        gradient.addColorStop(0.8, color.replace('1)', '0)'));
                        return gradient;
                    };
                    selectedStocksInChart.value.forEach(ticker => {
                        const stock = stockData[ticker];
                        if (!stock) return;
                        
                        chartInstance.data.datasets.push({
                            label: `${ticker} Hist.`, data: stock.prices, borderColor: stock.color,
                            tension: 0.4, borderWidth: 2, pointRadius: 0, fill: true,
                            backgroundColor: createGlowGradient(stock.color)
                        });
                        const projectionData = Array(11).fill(null).concat([stock.lastPrice], stock.projection);
                        chartInstance.data.datasets.push({
                            label: `${ticker} Proy.`, data: projectionData, borderColor: stock.color,
                            borderDash: [3, 3], tension: 0.4, borderWidth: 2, pointRadius: 0
                        });
                    });
                    chartInstance.update();
                };

                onMounted(async () => {
                    const initialStocks = loadStocksFromStorage();
                    const results = await Promise.all(initialStocks.map(ticker => fetchStockData(ticker)));
                    results.forEach((data, index) => {
                        if (data) {
                            const ticker = initialStocks[index];
                            stockData[ticker] = data;
                            trackedStocks.value.push(ticker);
                            selectedStocksInChart.value.push(ticker);
                        }
                    });
                    isLoadingInitial.value = false;
                    setTimeout(() => {
                        if (trackedStocks.value.length > 0) {
                            initializeChart();
                            updateChart();
                        }
                    }, 0);
                });
                
                watch([selectedStocksInChart, trackedStocks], updateChart, { deep: true });

                return {
                    stockData, trackedStocks, selectedStocksInChart, activeDetailStock, newStockTicker, isLoading, isLoadingInitial, error,
                    addStock, removeStock, analyzeWithGemini,
                    setActiveDetail: (ticker) => activeDetailStock.value = ticker,
                    toggleStockInChart: (ticker) => {
                        const index = selectedStocksInChart.value.indexOf(ticker);
                        if (index > -1) {
                            selectedStocksInChart.value.splice(index, 1);
                        } else {
                            selectedStocksInChart.value.push(ticker);
                        }
                    }
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
